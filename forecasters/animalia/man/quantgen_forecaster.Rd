% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantgen_forecaster.R
\name{quantgen_forecaster}
\alias{quantgen_forecaster}
\title{Simple quantile autoregressive forecaster based on `quantgen`}
\usage{
quantgen_forecaster(
  df_list,
  forecast_date,
  training_window_size = 28,
  incidence_period = c("epiweek", "day"),
  ahead = 1:4,
  lags = 0,
  tau = evalcast::covidhub_probs(),
  transform = NULL,
  inv_transform = NULL,
  featurize = NULL,
  noncross = TRUE,
  noncross_points = c("all", "test", "train"),
  cv_type = c("forward", "random"),
  verbose = FALSE,
  save_wide_data = NULL,
  save_trained_models = NULL,
  ...
)
}
\arguments{
\item{df_list}{list of signal values to use for forecasting, of the format
that is returned by [covidcast::covidcast_signals()].}

\item{forecast_date}{Date object or string of the form "YYYY-MM-DD",
indicating date on which forecasts will be made about some period (e.g.,
epiweek). For example, if `forecast_date = "2020-05-11"`, `incidence_period
= "day"`, and `ahead = 3`, then, we'd be making forecasts for "2020-05-14".}

\item{training_window_size}{Size of the local training window to use. 
For example, if `n = 14`, and `incidence_period = "day"`, then to make a 
1-day-ahead forecast on December 15, we train on
data from November 1 to November 14.}

\item{incidence_period}{String indicating the incidence period, either
"epiweek" or "day".}

\item{ahead}{Vector of (one or more) integers. How many epiweeks/days ahead
are you forecasting? If `incidence_period = "epiweek"` and forecast_date is
Sunday or Monday, then `ahead = 1` means the epiweek that includes the
forecast date; if `forecast_date` falls on a Tuesday through Saturday, then
it is the following epiweek. If `incidence_period = "day"`, then `ahead =
1` means the day after forecast date.}

\item{lags}{Vector of lag values to use as features in the autoregressive
model. For example, setting `lags = c(0, 7, 14)` means we use the 
current value of each signal (defined by an
element of the `df` list), as well as the values 7 and 14 days ago, as the
features. Recall that the response is defined by the first element of the
`df` list. Note that `lags` can also be a list of vectors of lag
values, this list having the same length as the number of signals,
in order to apply a different set of shifts to each signal.
Default is 0, which means no additional lags (only current values) for each
signal. lags are always specified in days.}

\item{tau}{Vector of quantile levels for the probabilistic forecast. If not
specified, defaults to the levels required by the COVID Forecast Hub.}

\item{transform, inv_transform}{Transformation and inverse transformations to use
for the response/features. These are applied to the raw data before any
leads or lags. The former `transform` can be a function or a
list of functions, this list having the same length as the number of elements
in the `df` list, in order to apply the same transformation or a
different transformation to each signal. These transformations will be
applied before fitting the quantile model. The latter argument `inv_transform`
specifies the inverse transformation to use on the response variable
(inverse of `transform` if this is a function, or of `transform[[1]]` if
`transform` is a list), which will be applied post prediction from the
quantile model. Several convenience functions for transformations exist as
part of the `quantgen` package. Default is `NULL` for both `transform` and
`inv_transform`, which means no transformations are applied.}

\item{featurize}{Function to construct custom features before the quantile
model is fit. As input, this function must take a data frame with columns
`geo_value`, `time_value`, then the transformed, lagged signal values. This
function must return a data frame with columns `geo_value`, `time_value`,
then any custom features. This function may add/remove rows if desired.}

\item{noncross}{Should noncrossing constraints be applied? These force the
predicted quantiles to be properly ordered across all quantile levels being
considered. The default is `FALSE`. If `TRUE`, then noncrossing constraints
are applied to the estimated quantiles at all points specified by the next
argument.}

\item{noncross_points}{One of "all", "test", "train" indicating which points
to use for the noncrossing constraints: the default "all" means to use both
training and testing sets combined, while "test" or "train" means to use
just one set, training or testing, respectively.}

\item{cv_type}{One of "forward" or "random", indicating the type of
cross-validation to perform. If "random", then `nfolds` folds are chosen by
dividing training data points randomly (the default being `nfolds = 5`). If
"forward", the default, then we instead use a "forward-validation" approach
that better reflects the way predictions are made in the current time
series forecasting context. Roughly, this works as follows: the data points
from the first `n - nfolds` time values are used for model training, and
then predictions are made at the earliest possible forecast date after this
training period. We march forward one time point at a time and repeat. In
either case ("random" or "forward"), the loss function used for computing
validation error is quantile regression loss (read the documentation for
`quantgen::cv_quantile_lasso()` for more details); and the final quantile
model is refit on the full training set using the validation-optimal tuning
parameter.}

\item{verbose}{Should progress be printed out to the console? Default is
`FALSE`.}

\item{save_wide_data, save_trained_models}{if NULL (the default), nothing
happens. Otherwise these should be directory paths to save off the input
data and/or trained model fits. These will be written as RDS files to the
destination directory with names of the form `quantgen_*_forecast_date.RDS`}

\item{...}{Additional arguments. Any parameter accepted by
`quantgen::cv_quantile_lasso()` (for model training) or by
`quantgen:::predict.cv_quantile_genlasso()` (for model prediction) can be
passed here. For example, `nfolds`, for specifying the number of folds used
in cross-validation, or `lambda`, for specifying the tuning parameter
values over which to perform cross-validation (the default allows
`quantgen::cv_quantile_lasso()` to set the lambda sequence itself). Note
that fixing a single tuning parameter value (such as `lambda = 0`)
effectively disables cross-validation and fits a quantile model at the
given tuning parameter value (here unregularized quantile autoregression).}
}
\value{
Data frame with columns `ahead`, `geo_value`, `quantile`, and
  `value`. The `quantile` column gives the probabilities associated with
  quantile forecasts for that location and ahead. This is the format expected
  for use with `[evalcast::get_predictions()]`
}
\description{
A simple quantile autoregressive forecaster based on `quantgen`, to be used
with `evalcast`, via [evalcast::get_predictions()]. See the 
[quantgen forecast vignette](https://cmu-delphi.github.io/covidcast/modeltoolsR/articles/quantgen-forecast.html)
for examples.
}
\details{
This is a developing variation of [modeltools::quantgen_forecaster()].
}
